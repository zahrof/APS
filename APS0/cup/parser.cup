package parser;

import java.io.*;
import java_cup.runtime.*;
import java.util.ArrayList;
import lexer.Lexer;
import ast.*; 

class Parser;

parser code {:
  public Parser (java.io.Reader input) {
    super(new Lexer(input));
  }
:};

/* Non terminals */
non terminal AstProgramme prog;
non terminal ArrayList<AstCommand> cmds;
non terminal AstStatement stat;
non terminal AstDeclaration dec;
non terminal AstType type;
non terminal ArrayList<AstType> types;
non terminal AstArgument arg;
non terminal ArrayList<AstArgument> args;
non terminal AstExpression expr;
non terminal ArrayList<AstExpression> exprs;

terminal LBAR, RBAR, LPAR, RPAR, SEMCOL, COMMA, STAR, ARROW, TWOPOINTS;
terminal TRUE, FALSE, BOOL, INT, IF, CONST, FUN, REC, ECHO;
terminal String OPRIM;
terminal Integer NUM;
terminal String IDENT;
start with prog;


/* grammar */
prog  ::=   LBAR cmds:c RBAR 
  {: RESULT = new AstProgramme(c); :} ;

cmds  ::= stat:s expr   
          {: ArrayList<AstCommand> l = new ArrayList<AstCommand>(); 
             l.add(0,s);
             RESULT = l; :} 
          | 
          dec:d SEMCOL cmds:cs
          {: cs.add(0,d);
             RESULT = cs; :}
          |
          stat:s SEMCOL cmds:cs
          {: cs.add(0,s);
             RESULT = cs; :};

stat  ::= ECHO expr:e
          {: RESULT = new AstEcho("ECHO",e); :};

dec   ::= CONST IDENT:id type:t expr:e
          {: RESULT = new AstConst(id,t,e); :}
          |
          FUN IDENT:id type:t LBAR args:as RBAR expr:e
          {: RESULT = new AstFun(id,t,as,e); :}
          |
          FUN REC IDENT:id type:t LBAR args:as RBAR expr:e
          {: RESULT = new AstFunRec(id,t,as,e); :};

type  ::= BOOL  
          {: RESULT = new AstBoolType(); :}
          |
          INT
          {: RESULT = new AstIntType(); :}
          |
          LPAR types:targs ARROW type:tres RPAR
          {: RESULT = new AstFuncType(targs,tres); :};

types ::= type:t
          {: ArrayList<AstType> l = new ArrayList<AstType>(); 
             l.add(0,t);
             RESULT = l; :}
          |
          type:t STAR types:ts
          {: ts.add(0,t);
             RESULT = ts; :};

arg   ::= IDENT:id TWOPOINTS type:t
          {: RESULT = new AstArgument(id,t); :};

args  ::= arg:a
          {: ArrayList<AstArgument> l = new ArrayList<AstArgument>(); 
             l.add(0,a);
             RESULT = l; :}
          |
          arg:a COMMA args:as
          {: as.add(0,a); 
             RESULT = as; :};

expr  ::= NUM:i
          {: RESULT = new AstNum(i); :}
          |
          TRUE
          {: RESULT = new AstBool(true); :}
          |
          FALSE
          {: RESULT = new AstBool(false); :}
          |
          IDENT:v
          {: RESULT = new AstVar(v); :}
          |
          LPAR IF expr:cond expr:cons expr:alt RPAR
          {: RESULT = new AstIf(cond,cons,alt); :}
          |
          LPAR OPRIM:o exprs:es RPAR
          {: RESULT = new AstOp(o,es); :}
          |
          LBAR args:as RBAR expr:e
          {: RESULT = new AstLambda(as,e); :}
          |
          LPAR expr:e exprs:es RPAR
          {: RESULT = new AstApplication(e,es); :};

exprs ::= expr:e
          {: ArrayList<AstExpression> l = new ArrayList<AstExpression>(); 
             l.add(0,e);
             RESULT = l; :}
          |
          expr:e exprs:es
          {: es.add(0,e);
             RESULT = es; :};
package parser;

import java.io.*;
import java_cup.runtime.*;
import java.util.ArrayList;

class Parser;

parser code {:
  public Parser (java.io.Reader input) {
    super(new Lexer(input));
  }
:};

/* Non terminals */
non terminal AstProgramme prog;
non terminal ArrayList<AstCommand> cmds;
non terminal AstStatement cmd;
non terminal AstDeclaration dec;
non terminal AstType type;
non terminal ArrayList<AstType> types;
non terminal AstArgument arg;
non terminal ArrayList<AstArgument> args;
non terminal AstExpression expr;
non terminal ArrayList<AstExpression> exprs;

start with prog;


/* grammar */
prog  ::=   LBAR cmds:c RBAR 
  {: RESULT = new AstProgramme(c) :} ;

cmds  ::= cmd:c expr   
          {: RESULT = (new ArrayList<AstCommand>()).add(0,c); :} 
          | 
          dec:d SEMCOL cmds:cs
          {: cs.add(0,d);
             RESULT = cs:}
          |
          stat: SEMCOL cmds:cs
          {: RESULT = cs.add(0,d); :};

stat  ::= ECHO expr:e
          {: RESULT = new AstEcho("ECHO",e); :};

dec   ::= CONST IDENT:id type:t expr:e
          {: RESULT = new AstConst(id,t,e); :}
          |
          FUN IDENT:id type:t LBAR args:as RBAR expr:e
          {: RESULT = new AstFun(id,t,as,e); :}
          |
          FUN REC IDENT:id type:t LBAR args:as RBAR expr:e
          {: RESULT = new AstFunRec(id,t,as,e); :};

type  ::= BOOL  
          {: RESULT = new AstBoolType(); :}
          |
          INT
          {: RESULT = new AstIntType(); :}
          |
          LPAR types:targs ARROW type:tres RPAR
          {: RESULT = new AstFuncType(targs,tres); :};

types ::= type:t
          {: RESULT = (new ArrayList<AstType>()).add(0,t); :}
          |
          type:t STAR types:ts
          {: ts.add(0,t);
             RESULT = ts :};

args  ::= arg:a
          {: (new ArrayList<AstArgument>()).add(0,a); :}
          |
          arg:a COMMA args:as
          {: as.add(0,a); 
             RESULT = as:};

expr  ::= NUM:i
          {: new AstNum(i); :}
          |
          TRUE
          {: new AstBool(true); :}
          |
          FALSE
          {: new AstBool(false); :}
          |
          IDENT:v
          {: new AstVar(v); :}
          |
          LPAR IF expr:cond expr:cons expr:alt RPAR
          {: new AstIf(cond,cons,alt); :}
          |
          LPAR OPRIM:o exprs:es RPAR
          {: new AstOp(o,es); :}
          |
          LBAR args:as RBAR expr:e
          {: new AstLambda(as,e); :}
          |
          LPAR expr:e exprs:es RPAR
          {: new AstApplication(e,es); :};

exprs ::= expr:e
          {: (new ArrayList<AstExpression>()).add(0,e); :}
          |
          expr:e exprs:es
          {: es.add(0,e);
             RESULT = es; :};
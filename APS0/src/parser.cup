package parser;

import java.io.*;
import java_cup.runtime.*;
import java.util.ArrayList;

class Parser;

parser code {:
  private ArrayList<AstCommand> commandes = new ArrayList<>();
  private ArrayList<AstDeclaration> declarations= new ArrayList<>();

  public Parser (java.io.Reader input) {
    super(new Lexer(input));
  }
:};

/* Non terminals */
non terminal AstProgramme prog;
non terminal cmds;
non terminal AstCommand cmd;
non terminal AstDeclaration dec;
non terminal AstType type;
non terminal ArrayList<AstType> types;
non terminal AstArgument arg;
non terminal ArrayList<AstArgument> args;
non terminal AstExpression expr;
non terminal ArrayList<AstExpression> exprs;

start with prog;


/* grammar */
prog  ::=   LBAR cmds RBAR 
  {: RESULT = new AstProgramme(declarations,commandes) :} 

cmds  ::= cmd:c expr   
          {: commandes.add(c); :} 
          | 
          dec:d SEMCOL cmds
          {: declarations.add(d) :}
          |

type:
BOOL  { $$ = new AstType(TPrim.BOOL); }
| INT { $$ = new AstType(TPrim.INT); }
| LPAR types ARROW type RPAR  { $$ = new AstType((ArrayList<Ast>)$2, $); }

types:
type { ArrayList<Ast> r = new ArrayList<Ast>(); t.add((Ast)$1); $$ = t  ; }
| type STAR types   { ((ArrayList<Ast>)$2).add((Ast)$1); $$ = $3; }

expr:
  NUM                      { $$ = new AstNum($1); }
| TRUE 			{ $$ = new AstBool(cBool.TRUE); }
| FALSE			{ $$ = new AstBool(cBool.FALSE); }
| IDENT                    { $$ = new AstId($1); }
| LPAR PLUS exprs RPAR   { $$ = new AstPrim(Op.ADD,(ArrayList<Ast>)$3); }
| LPAR MINUS exprs RPAR  { $$ = new AstPrim(Op.SUB,(ArrayList<Ast>)$3); }
| LPAR TIMES exprs RPAR  { $$ = new AstPrim(Op.MUL,(ArrayList<Ast>)$3); }
| LPAR DIV exprs RPAR    { $$ = new AstPrim(Op.DIV,(ArrayList<Ast>)$3); }
| LPAR LT exprs RPAR    { $$ = new AstPrim(Op.LT,(ArrayList<Ast>)$3); }
| LPAR EQ exprs RPAR    { $$ = new AstPrim(Op.EQ,(ArrayList<Ast>)$3); }
| LPAR OR exprs RPAR    { $$ = new AstPrim(Op.OR,(ArrayList<Ast>)$3); }
| LPAR AND exprs RPAR    { $$ = new AstPrim(Op.AND,(ArrayList<Ast>)$3); }
| LPAR NOT exprs RPAR    { $$ = new AstPrim(Op.NOT,(ArrayList<Ast>)$3); }
| LPAR IF expr expr expr RPAR  { $$ = new AstIf((Ast)$3,(Ast)$4,(Ast)$5 ); }
;
exprs:
expr                   { ArrayList<Ast> r = new ArrayList<Ast>(); r.add((Ast)$1); $$ = r; }
| expr exprs           { ((ArrayList<Ast>)$1).add((Ast)$2); $$ = $2; }
;
%%
  public Ast prog;

  private Yylex lexer;

  private int yylex () {
	  int yyl_return = -1;
	  try {
		yylval = new ParserVal(0);
		yyl_return = lexer.yylex();
	  }catch (IOException e) {
	    System.err.println("IO error :"+e);
	  }
	  return yyl_return;
  }

  public void yyerror (String error) {
	System.err.println ("Error: " + error);
  }

  public Parser(Reader r) {
	lexer = new Yylex(r, this);
  }